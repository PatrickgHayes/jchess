R1	 [ C ][*H*][ B ][*Q*][ K ][*B*][ H ][*C*]

R2	 [*P*][ P ][*P*][ P ][*P*][ P ][*P*][ P ]

R3	 [   ][* *][   ][* *][   ][* *][   ][* *]

R4	 [* *][   ][* *][   ][* *][   ][* *][   ]

R5	 [   ][* *][   ][* *][   ][* *][   ][* *]

R6	 [* *][   ][* *][   ][* *][   ][* *][   ]

R7	 [ p ][*p*][ p ][*p*][ p ][*p*][ p ][*p*]

R8	 [*c*][ h ][*b*][ q ][*k*][ b ][*h*][ c ]



	   1    2    3    4    5    6    7    8
	   C    C    C    C    C    C    C    C





    ------------------------
R1 | c [h] b [q] k [b] h [c]|
R2 |[p] p [p] p [p] p [p] p |
R3 |   [ ]   [ ]   [ ]   [ ]|
R4 |[ ]   [ ]   [ ]   [ ]   |
R5 |   [ ]   [ ]   [ ]   [ ]|
R6 |[ ]   [ ]   [ ]   [ ]   |
R7 | P [P] P [P] P [P] P [P]|
R8 |[C] H [B] Q [K] B [H] C |
    ------------------------

     C  C  C  C  C  C  C  C
     1  2  3  4  5  6  7  8    


Improvement steps:
* Undo function [done]
* Place function [done]
* Move zero indexing logic to the input parsing.
* Allow user input to be piece name (must make pawns etc. seperate)
   and move and direction amount
* display history
* redo
* save game board


example of commands:
* place P r1c3
* undo
* move r1c2 r3c4
* checkmate


example of undo stack:
move 2 1 3 1 _
move 4 4 4 9 'q'
place Q 5 5  _
place q 5 5 Q


